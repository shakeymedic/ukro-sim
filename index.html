<!DOCTYPE html>
<html lang="en-GB">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>UKRO High-Fidelity Scenario Simulator (Instructor)</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <!-- PDF export libs -->
  <script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js"></script>
  <style>
    body { font-family: 'Inter', sans-serif; background-color: #111827; }
    .btn { border-bottom-width: 4px; transition: all 0.1s ease-in-out; }
    .btn:hover { transform: translateY(-2px); }
    .btn:active { transform: translateY(1px); }
    .btn-primary { background-color: #0057b7; border-color: #003d82; color:#fff; }
    .btn-primary:hover { background-color: #0069d9; }
    .btn-secondary { background-color: #d90429; border-color: #a3001d; color:#fff; }
    .btn-secondary:hover { background-color: #e63946; }
    .btn-tertiary { background-color: #f59e0b; border-color: #b45309; color:#111; }
    .btn-tertiary:hover { background-color: #fbbf24; }
    .chip { display:inline-block; padding:0.1rem 0.5rem; border-radius:9999px; font-size:0.75rem; }
    .chip-ev { background:#064e3b; color:#bbf7d0; }
    .chip-uhss { background:#1f2937; color:#e5e7eb; }
    /* Flash red animation when a casualty deteriorates
       Increase visibility by adding a soft red background and stronger shadow.
       The effect lasts longer to draw attention to the change. */
    .flash-red {
      /* enhanced flash effect: apply a red border and glow with a subtle background to highlight deterioration */
      animation: flash-red 1.5s ease-in-out;
      border: 2px solid rgba(239, 68, 68, 1);
      box-shadow: 0 0 8px 4px rgba(239, 68, 68, 0.6);
      background-color: rgba(239, 68, 68, 0.12);
    }
    @keyframes flash-red {
      0%, 100% {
        box-shadow: 0 0 0 0 rgba(239, 68, 68, 0);
        border-color: rgba(239, 68, 68, 0.8);
        background-color: transparent;
      }
      50% {
        box-shadow: 0 0 20px 6px rgba(239, 68, 68, 0.9);
        border-color: rgba(239, 68, 68, 1);
        background-color: rgba(239, 68, 68, 0.15);
      }
    }
    @media print {
      body { background-color: white; color: black; }
      #main-menu, #controls, #startSimBtn, header, footer { display: none !important; }
      #setup-screen { display: block !important; box-shadow: none; border: none; padding: 0; }
      .bg-gray-800, .bg-gray-900 { background-color: #f3f4f6; border: 1px solid #d1d5db; }
      .text-white { color: black !important; }
      canvas { border: 1px solid #ccc; }
    }
  </style>
</head>
<body class="text-gray-200 p-4">
  <div class="w-full max-w-7xl mx-auto">
    <header class="text-center mb-6">
      <h1 class="text-3xl md:text-4xl font-bold text-white">UKRO High-Fidelity Scenario Simulator</h1>
      <p class="text-lg text-gray-400 mt-2">Instructor Control Panel</p>
    </header>

    <div id="app" class="w-full"></div>

    <footer class="text-center mt-8 py-6 border-t border-gray-700 text-gray-500 text-sm">
      <p>Developed by Dr Jake Turner for West Midlands Evidence Based Emergency Medicine Ltd.</p>
      <p>Feedback: <a href="mailto:Jaketurner2503@gmail.com?subject=UKRO%20Simulator%20Feedback" class="text-blue-400 hover:underline">Email Us</a></p>
      <p class="mt-2">Licensed under <a href="http://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" class="text-blue-400 hover:underline">CC BY-NC-SA 4.0</a></p>
    </footer>
  </div>

  <script type="module">
// Inline script combining all modules (data, scenario, drawing, log, sim, ui, main) for Netlify.
// data.js
const frameworkData = {
  scoresheets: {
    command: [
      'Scene assessment & survey',
      'Formulation of tactical plan',
      'Clear communication',
      'Dynamic risk assessment',
      'Scene safety',
      'Crew resource management'
    ],
    technical: [
      'Vehicle stabilisation',
      'Glass management',
      'Use of hydraulic tools',
      'Extrication pathway',
      'Vehicle hazards (UHSS, EV)'
    ],
    trauma: [
      'Scene safety & approach',
      '<C>ABCDE assessment',
      'Identify/manage life-threats',
      'Teamwork & communication',
      'Ongoing reassessment',
      'ATMIST handover'
    ]
  },

  injuries: {
    'Tension Pneumothorax': {
      name: 'Tension Pneumothorax',
      type: 'major',
      canSelfExtricate: false,
      bodyPart: 'chest_left',
      marker: 'T',
      moulage: 'Distended neck veins, hyper-resonant chest, tracheal deviation (late).',
      briefing: 'Extreme shortness of breath, cannot complete sentences.',
      vitals: { GCS: 14, HR: 135, RR: 38, SBP: 85, SpO2: 82 },
      deterioration: { SpO2: -4, SBP: -5, HR: 5 },
      interventions: {}
    },
    'Catastrophic Haemorrhage (Thigh)': {
      name: 'Catastrophic Haemorrhage (Thigh)',
      type: 'major',
      canSelfExtricate: false,
      bodyPart: 'leg_right',
      marker: 'C',
      moulage: 'Pulsatile bleed, clothing soaked.',
      briefing: 'Pale, clammy, very anxious.',
      vitals: { GCS: 13, HR: 140, RR: 30, SBP: 80, SpO2: 92 },
      deterioration: { SBP: -8, HR: 6, GCS: -1 },
      interventions: {
        'Apply Tourniquet': {
          key: 'Apply Tourniquet',
          effect: { SBP: 15, HR: -20 },
          stopsDeterioration: true,
          feedback: 'Tourniquet applied. Haemorrhage controlled.'
        }
      }
    },
    'Severe Head Injury': {
      name: 'Severe Head Injury',
      type: 'major',
      canSelfExtricate: false,
      bodyPart: 'head',
      marker: 'H',
      moulage: 'Laceration to forehead, one pupil dilated.',
      briefing: 'GCS 8 (E2, V2, M4). Moans to pain.',
      vitals: { GCS: 8, HR: 55, RR: 26, SBP: 180, SpO2: 95 },
      deterioration: { GCS: -1, RR: -2 },
      interventions: {
        'Airway Management': {
          key: 'Airway Management',
          effect: { RR: 2 },
          stopsDeterioration: true,
          feedback: 'Airway manoeuvre performed, halting deterioration.'
        }
      }
    },
    'Lateral Flail Chest': {
      name: 'Lateral Flail Chest',
      type: 'major',
      canSelfExtricate: false,
      bodyPart: 'chest_left',
      marker: 'F',
      moulage: 'Bruising over left chest, paradoxical movement.',
      briefing: 'Shallow, slow breathing; becoming unresponsive.',
      vitals: { GCS: 7, HR: 130, RR: 6, SBP: 90, SpO2: 86 },
      deterioration: { SpO2: -5, RR: -1 },
      interventions: {
        'Positive Pressure Ventilation': {
          key: 'Positive Pressure Ventilation',
          effect: { SpO2: 8, RR: 6 },
          stopsDeterioration: true,
          feedback: 'PPV initiated, assisting breathing.'
        }
      }
    },
    'Unstable Pelvic Fracture': {
      name: 'Unstable Pelvic Fracture',
      type: 'major',
      canSelfExtricate: false,
      bodyPart: 'pelvis',
      marker: 'P',
      moulage: 'Bruising over pelvic wings, leg length discrepancy.',
      briefing: 'Severe pelvic pain, distressed.',
      vitals: { GCS: 13, HR: 130, RR: 28, SBP: 80, SpO2: 92 },
      deterioration: { SBP: -10, HR: 8 },
      interventions: {
        'Apply Pelvic Binder': {
          key: 'Apply Pelvic Binder',
          effect: { SBP: 10 },
          stopsDeterioration: true,
          feedback: 'Pelvic binder applied, providing stability.'
        }
      }
    },
    'Open Femur Fracture': {
      name: 'Open Femur Fracture',
      type: 'major',
      canSelfExtricate: false,
      bodyPart: 'leg_left',
      marker: 'OF',
      moulage: 'Bone visible through wound, heavy bleeding.',
      briefing: 'Screaming in pain, bleeding heavily.',
      vitals: { GCS: 15, HR: 120, RR: 28, SBP: 95, SpO2: 96 },
      deterioration: { HR: 5, SBP: -5 },
      interventions: {}
    },
    'Asthmatic Exacerbation': {
      name: 'Asthmatic Exacerbation',
      type: 'moderate',
      canSelfExtricate: true,
      bodyPart: 'chest_centre',
      marker: 'A',
      moulage: 'Wheeze audible, accessory muscle use.',
      briefing: 'History of asthma, struggling to speak.',
      vitals: { GCS: 15, HR: 110, RR: 32, SBP: 130, SpO2: 89 },
      deterioration: { SpO2: -2, RR: 2 },
      interventions: {}
    },
    'Severe Laceration (Forearm)': {
      name: 'Severe Laceration (Forearm)',
      type: 'minor',
      canSelfExtricate: true,
      bodyPart: 'arm_left',
      marker: 'W',
      moulage: 'Deep laceration to forearm, steady dark red flow.',
      briefing: 'Alert but in pain, worried about bleeding.',
      vitals: { GCS: 15, HR: 100, RR: 20, SBP: 115, SpO2: 98 },
      deterioration: { HR: 2 },
      interventions: {
        'Apply Wound Dressing': {
          key: 'Apply Wound Dressing',
          effect: { HR: -10 },
          stopsDeterioration: true,
          feedback: 'Dressing applied. Bleeding controlled.'
        }
      }
    },
    'Wrist Fracture': {
      name: 'Wrist Fracture',
      type: 'minor',
      canSelfExtricate: true,
      bodyPart: 'arm_right',
      marker: '#',
      moulage: 'Visible deformity to wrist ("dinner fork").',
      briefing: 'Severe wrist pain.',
      vitals: { GCS: 15, HR: 95, RR: 18, SBP: 125, SpO2: 99 },
      deterioration: { HR: 1 },
      interventions: {}
    },
    'Elderly Fall + Head Laceration': {
      name: 'Elderly Fall + Head Laceration',
      type: 'minor',
      canSelfExtricate: true,
      bodyPart: 'head',
      marker: 'L',
      moulage: 'Small scalp wound, oozing blood.',
      briefing: '80-year-old with AF on anticoagulants.',
      vitals: { GCS: 14, HR: 80, RR: 18, SBP: 140, SpO2: 97 },
      deterioration: { GCS: -1 },
      interventions: {}
    },
    'Chemical Burn (Arm)': {
      name: 'Chemical Burn (Arm)',
      type: 'moderate',
      canSelfExtricate: false,
      bodyPart: 'arm_right',
      marker: 'B',
      moulage: 'Skin blistering and redness, chemical odour.',
      briefing: 'Severe stinging pain after exposure.',
      vitals: { GCS: 15, HR: 105, RR: 20, SBP: 125, SpO2: 98 },
      deterioration: { HR: 3 },
      interventions: {}
    }
  },

  ampleHistory: {
    allergies: ['NKDA', 'Penicillin', 'Latex', 'Nuts'],
    medications: ['None', 'Warfarin', 'DOAC', 'Insulin', 'Salbutamol inhaler', 'Aspirin'],
    pastHistory: ['Asthma', 'Diabetes', 'Hypertension', 'IHD', 'COPD', 'Epilepsy'],
    lastMeal: ['Breakfast', 'Sandwich at lunch', 'Tea', 'Snack', 'Skipped meal'],
    events: ['Driving home from work', 'Climbing ladder', 'Using power tools', 'Working in factory', 'Cycling to shop']
  },

  vehicles: {
    'Saloon Car': {
      type: 'Saloon Car',
      capacity: 5,
      hasUHSS: false,
      isEV: false,
      length_m: 4.6
    },
    'Tesla Model 3': {
      type: 'Tesla Model 3',
      capacity: 5,
      hasUHSS: true,
      isEV: true,
      length_m: 4.7
    }
  },

  vehiclePositions: [
    { name: 'Upright on all fours', rotation: 0 },
    { name: 'On roof', rotation: 180 },
    { name: 'Driver’s side', rotation: 90 },
    { name: 'Passenger’s side', rotation: -90 }
  ],

  hazardTemplates: [
    { type: 'Fuel Spill', minR: 35, maxR: 70 },
    { type: 'Fire', minR: 15, maxR: 28 },
    { type: 'Wall', width_m: 4, height_m: 0.5 },
    { type: 'Lamppost' },
    { type: 'Battery Fire', minR: 18, maxR: 28 }
  ],

  casualtyPositions: {
    'Driver': { x: 25, y: -40 },
    'Front Passenger': { x: -25, y: -40 },
    'Rear Offside': { x: 25, y: 40 },
    'Rear Nearside': { x: -25, y: 40 }
  }
};// scenario.js

const rand = (min, max) => Math.random() * (max - min) + min;
const randInt = (min, max) => Math.floor(rand(min, max + 1));
const choice = arr => arr[Math.floor(Math.random() * arr.length)];
const pickKeys = obj => Object.keys(obj);

const CANVAS_W = 900;
const CANVAS_H = 520;

function clamp(v, lo, hi) { return Math.max(lo, Math.min(hi, v)); }

function near(anchorX, anchorY, radius = 80) {
  const x = clamp(anchorX + rand(-radius, radius), 40, CANVAS_W - 40);
  const y = clamp(anchorY + rand(-radius, radius), 40, CANVAS_H - 40);
  return { x, y };
}

function randomLayoutType() {
  return Math.random() < 0.6 ? 't-junction' : 'offset-headon';
}

function makeCasualty(id) {
  const injuryKey = choice(pickKeys(frameworkData.injuries));
  const injury = frameworkData.injuries[injuryKey];
  const ageBuckets = [
    () => randInt(6, 12),
    () => randInt(16, 30),
    () => randInt(31, 55),
    () => randInt(65, 88)
  ];
  const age = Math.random() < 0.12 ? ageBuckets[0]() :
              Math.random() < 0.55 ? ageBuckets[1]() :
              Math.random() < 0.85 ? ageBuckets[2]() : ageBuckets[3]();

  const vitals = { ...injury.vitals };
  const prevVitals = { ...injury.vitals };

    return {
    id,
    age,
    injuries: [{ ...injury, key: injuryKey }],
    vitals,
    prevVitals,
    treatedInjuries: new Set(),
    entrapment: injury.canSelfExtricate ? 'No physical entrapment.' : 'Physical entrapment by intrusion.',
    ample: {
      A: choice(frameworkData.ampleHistory.allergies),
      M: choice(frameworkData.ampleHistory.medications),
      P: choice(frameworkData.ampleHistory.pastHistory),
      L: choice(frameworkData.ampleHistory.lastMeal),
      E: choice(frameworkData.ampleHistory.events)
    },
    // capture initial vitals at scenario start for later summary
    initialVitals: { ...vitals }
  };
}

function instantiateHazard(t, anchor) {
  const pos = near(anchor.x, anchor.y, 140);
  if (t.type === 'Fuel Spill') {
    const rx = rand(t.minR, t.maxR);
    const ry = rand(t.minR * 0.4, t.maxR * 0.7);
    return { type: t.type, x: pos.x, y: pos.y, rx, ry, rotation: rand(0, Math.PI) };
  }
  if (t.type === 'Fire' || t.type === 'Battery Fire') {
    const r = rand(t.minR, t.maxR);
    return { type: t.type, x: pos.x, y: pos.y, r };
  }
  if (t.type === 'Wall') {
    const w = t.width_m * 16;
    const h = t.height_m * 16;
    return { type: t.type, x: rand(80, CANVAS_W - w - 80), y: rand(60, 120), w, h };
  }
  if (t.type === 'Lamppost') {
    return { type: t.type, x: rand(70, CANVAS_W - 70), y: rand(140, CANVAS_H - 140) };
  }
  return null;
}

function spawnHazards(vehicles, probability, forced = [], includeBatteryFire = false) {
  const anchor = vehicles[0]
    ? { x: vehicles[0].x, y: vehicles[0].y }
    : { x: CANVAS_W * 0.5, y: CANVAS_H * 0.5 };

  const isEVPresent = vehicles.some(v => v.isEV);

  const pool = frameworkData.hazardTemplates.filter(t => {
    if (t.type === 'Battery Fire' && !(isEVPresent && includeBatteryFire)) return false;
    return true;
  });

  const chosen = pool
    .map(t => {
      if (forced.includes(t.type)) return instantiateHazard(t, anchor);
      if (t.type === 'Battery Fire') return null;
      if (Math.random() >= probability) return null;
      return instantiateHazard(t, anchor);
    })
    .filter(Boolean);

  const unique = [];
  const seen = new Set();
  for (const h of chosen) {
    const k = `${h.type}-${Math.round(h.x)}-${Math.round(h.y)}`;
    if (!seen.has(k)) { unique.push(h); seen.add(k); }
  }
  return unique;
}

function spawnVehicles(numVehicles, layout) {
  const vehicleKeys = pickKeys(frameworkData.vehicles);
  const colors = ['#93c5fd', '#fde047', '#a7f3d0', '#fda4af'];

  const vehicles = [];
  if (layout === 't-junction') {
    for (let i = 0; i < numVehicles; i++) {
      const proto = frameworkData.vehicles[choice(vehicleKeys)];
      const baseX = i === 0 ? CANVAS_W * 0.42 : CANVAS_W * 0.53;
      const baseY = i === 0 ? CANVAS_H * 0.40 : CANVAS_H * 0.56;
      const rotation = i === 0 ? rand(-12, 12) : rand(78, 100);
      vehicles.push({
        id: i,
        type: proto.type,
        capacity: proto.capacity,
        hasUHSS: proto.hasUHSS,
        isEV: proto.isEV,
        length_m: proto.length_m,
        color: colors[i % colors.length],
        position: { name: 'Upright on all fours', rotation },
        x: baseX + rand(-20, 20),
        y: baseY + rand(-15, 15),
        impactType: i === 0 ? 'frontal' : 'side',
        impactSide: i === 0 ? null : Math.random() < 0.5 ? 'nearside' : 'offside',
        damage: i === 0 ? 'Frontal intrusion from T-bone' : 'Severe side intrusion from T-bone',
        casualties: []
      });
    }
  } else {
    for (let i = 0; i < numVehicles; i++) {
      const proto = frameworkData.vehicles[choice(vehicleKeys)];
      vehicles.push({
        id: i,
        type: proto.type,
        capacity: proto.capacity,
        hasUHSS: proto.hasUHSS,
        isEV: proto.isEV,
        length_m: proto.length_m,
        color: colors[i % colors.length],
        position: { name: 'Upright on all fours', rotation: rand(-15, 15) },
        x: CANVAS_W * (0.35 + i * 0.18) + rand(-10, 10),
        y: CANVAS_H * (0.44 + i * 0.1) + rand(-12, 12),
        impactType: 'frontal',
        damage: 'Frontal intrusion from offset collision',
        casualties: []
      });
    }
  }
  return vehicles;
}

function generateRtcScenario(numVehicles = 2, numPatients = 2, options = {}) {
  const { hazardProbability = 0.55, forceHazards = [], includeEVBatteryHazard = false } = options;

  const layout = randomLayoutType();
  const vehicles = spawnVehicles(numVehicles, layout);

  const totalCapacity = vehicles.reduce((a, v) => a + v.capacity, 0);
  if (numPatients > totalCapacity) numPatients = totalCapacity;

  const casualties = [];
  for (let i = 0; i < numPatients; i++) casualties.push(makeCasualty(i));
  casualties.forEach((cas, idx) => {
    const v = vehicles[idx % vehicles.length];
    v.casualties.push({ ...cas });
  });

  const hazards = spawnHazards(vehicles, hazardProbability, forceHazards, includeEVBatteryHazard);

  return {
    type: 'RTC',
    title: 'RTC Challenge',
    timeLimit: 20,
    location: layout === 't-junction' ? 'Urban T-Junction' : 'Urban A-Road',
    hazards: hazards.map(h => h.type).join(', ') || 'None obvious',
    vehicles,
    casualties,
    environmentalObjects: hazards,
    layoutType: layout,
    canvas: { width: CANVAS_W, height: CANVAS_H }
  };
}

function generateTraumaScenario(numPatients = 2, options = {}) {
  const { hazardProbability = 0.42, forceHazards = [], includeEVBatteryHazard = false } = options;

  const casualties = [];
  for (let i = 0; i < numPatients; i++) casualties.push(makeCasualty(i));

  const vehicles = [{
    id: 0,
    type: 'Support Van',
    capacity: 2,
    hasUHSS: false,
    isEV: false,
    length_m: 4.8,
    color: '#94a3b8',
    position: { name: 'Upright', rotation: rand(-8, 8) },
    x: CANVAS_W * 0.5,
    y: CANVAS_H * 0.48,
    impactType: 'none',
    damage: 'N/A',
    casualties: []
  }];

  const hazards = spawnHazards(vehicles, hazardProbability, forceHazards, includeEVBatteryHazard);

  return {
    type: 'Trauma',
    title: 'Trauma Challenge',
    timeLimit: 12,
    location: 'Industrial unit',
    hazards: hazards.map(h => h.type).join(', ') || 'None obvious',
    vehicles,
    casualties,
    environmentalObjects: hazards,
    layoutType: 't-junction',
    canvas: { width: CANVAS_W, height: CANVAS_H }
  };
}// drawing.js

// Draws road layout, vehicles, casualties, and hazards (incl. EV Battery Fire).

function drawSetupScene(canvas, scenario) {
  if (!canvas || !scenario) return;
  const ctx = canvas.getContext('2d');
  const W = canvas.width;
  const H = canvas.height;

  ctx.clearRect(0, 0, W, H);
  drawRoadLayout(ctx, W, H, scenario.layoutType);

  (scenario.environmentalObjects || []).forEach(h => drawHazard(ctx, h));

  (scenario.vehicles || []).forEach((v, idx) => {
    drawVehicle(ctx, v.x, v.y, v.position.rotation, v.color, String.fromCharCode(65 + idx), v.type, v.isEV, v.hasUHSS);
    if (v.impactType === 'frontal') {
      drawImpact(ctx, v.x, v.y, v.position.rotation, 60);
    } else if (v.impactType === 'side') {
      drawSideImpact(ctx, v.x, v.y, v.position.rotation, v.impactSide);
    }
    (v.casualties || []).forEach((cas, ci) => {
      const ox = (ci % 2 === 0 ? -20 : 20) + rand(-8, 8);
      const oy = (ci < 2 ? -26 : 18) + rand(-6, 6);
      drawCasualty(ctx, v.x + rotateX(ox, oy, v.position.rotation), v.y + rotateY(ox, oy, v.position.rotation), `C${cas.id + 1}`);
    });
  });
}

function drawRoadLayout(ctx, W, H, type) {
  ctx.fillStyle = '#14532d';
  ctx.fillRect(0, 0, W, H);

  ctx.fillStyle = '#4b5563';
  if (type === 't-junction') {
    ctx.fillRect(0, H * 0.32, W, H * 0.36);
    ctx.fillRect(W * 0.35, 0, W * 0.3, H);
    ctx.strokeStyle = 'white';
    ctx.setLineDash([14, 22]);
    line(ctx, 0, H * 0.5, W, H * 0.5);
    line(ctx, W * 0.5, 0, W * 0.5, H);
    ctx.setLineDash([]);
  } else {
    ctx.fillRect(0, H * 0.36, W, H * 0.28);
    ctx.fillStyle = '#374151';
    ctx.fillRect(W * 0.72, H * 0.2, W * 0.18, H * 0.2);
    ctx.strokeStyle = 'white';
    ctx.setLineDash([14, 22]);
    line(ctx, 0, H * 0.5, W, H * 0.5);
    ctx.setLineDash([]);
  }
}

function drawVehicle(ctx, x, y, rotationDeg, color, label, type, isEV, hasUHSS) {
  ctx.save();
  ctx.translate(x, y);
  ctx.rotate((rotationDeg * Math.PI) / 180);

  ctx.fillStyle = color || '#93c5fd';
  roundRect(ctx, -52, -24, 104, 48, 6, true, false);

  ctx.fillStyle = '#bfdbfe';
  roundRect(ctx, -36, -18, 72, 16, 4, true, false);

  ctx.rotate(0);
  ctx.fillStyle = 'white';
  ctx.font = 'bold 16px Inter';
  ctx.textAlign = 'center';
  ctx.fillText(label, 0, -34);
  ctx.font = '10px Inter';
  ctx.fillText(type, 0, 38);

  if (isEV) {
    ctx.fillStyle = '#064e3b';
    roundRect(ctx, -50, -46, 36, 14, 7, true, false);
    ctx.fillStyle = '#bbf7d0';
    ctx.font = '10px Inter';
    ctx.fillText('EV', -32, -36);
  }
  if (hasUHSS) {
    ctx.fillStyle = '#1f2937';
    roundRect(ctx, 14, -46, 40, 14, 7, true, false);
    ctx.fillStyle = '#e5e7eb';
    ctx.font = '10px Inter';
    ctx.fillText('UHSS', 34, -36);
  }

  ctx.restore();
}

function drawCasualty(ctx, x, y, label) {
  ctx.save();
  ctx.fillStyle = '#ef4444';
  ctx.beginPath();
  ctx.arc(x, y, 8, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = 'white';
  ctx.font = '12px Inter';
  ctx.textAlign = 'center';
  ctx.fillText(label, x, y - 12);
  ctx.restore();
}

function drawImpact(ctx, x, y, rotationDeg, offset) {
  const ox = rotateX(0, -offset, rotationDeg);
  const oy = rotateY(0, -offset, rotationDeg);
  ctx.save();
  ctx.fillStyle = '#f97316';
  ctx.font = '20px Inter';
  ctx.fillText('💥', x + ox, y + oy);
  ctx.restore();
}

function drawSideImpact(ctx, x, y, rotationDeg, side) {
  const s = side === 'nearside' ? -1 : 1;
  const ox = rotateX(48 * s, 0, rotationDeg);
  const oy = rotateY(48 * s, 0, rotationDeg);
  ctx.save();
  ctx.fillStyle = '#f97316';
  ctx.font = '20px Inter';
  ctx.fillText('💥', x + ox, y + oy);
  ctx.restore();
}

function drawHazard(ctx, h) {
  ctx.save();
  if (h.type === 'Fuel Spill') {
    ctx.translate(h.x, h.y);
    ctx.rotate(h.rotation || 0);
    ctx.fillStyle = 'rgba(59,130,246,0.35)';
    ellipse(ctx, 0, 0, h.rx || 50, h.ry || 25, true, false);
    ctx.fillStyle = 'white';
    ctx.font = '11px Inter';
    ctx.textAlign = 'center';
    ctx.fillText('Fuel Spill', 0, 0);
  } else if (h.type === 'Fire') {
    ctx.fillStyle = '#fb923c';
    ctx.beginPath();
    ctx.arc(h.x, h.y, h.r || 20, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = '#ef4444';
    ctx.font = '14px Inter';
    ctx.textAlign = 'center';
    ctx.fillText('🔥 Fire', h.x, h.y + 4);
  } else if (h.type === 'Battery Fire') {
    ctx.fillStyle = '#fb923c';
    ctx.beginPath();
    ctx.arc(h.x, h.y, h.r || 20, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = '#ef4444';
    ctx.font = '14px Inter';
    ctx.textAlign = 'center';
    ctx.fillText('🔋🔥', h.x, h.y + 4);
  } else if (h.type === 'Wall') {
    ctx.fillStyle = '#8b5cf6';
    roundRect(ctx, h.x, h.y, h.w || 80, h.h || 12, 4, true, false);
    ctx.fillStyle = 'white';
    ctx.font = '11px Inter';
    ctx.fillText('Wall', h.x + (h.w || 80) / 2, (h.y || 0) - 6);
  } else if (h.type === 'Lamppost') {
    ctx.fillStyle = '#d1d5db';
    ctx.fillRect(h.x - 5, h.y - 40, 10, 60);
    ctx.fillStyle = '#facc15';
    ctx.beginPath();
    ctx.arc(h.x, h.y - 44, 12, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = 'white';
    ctx.font = '11px Inter';
    ctx.textAlign = 'center';
    ctx.fillText('Lamp', h.x, h.y - 60);
  }
  ctx.restore();
}

function line(ctx, x1, y1, x2, y2) {
  ctx.beginPath(); ctx.moveTo(x1, y1); ctx.lineTo(x2, y2); ctx.stroke();
}
function roundRect(ctx, x, y, w, h, r, fill, stroke) {
  if (typeof r === 'number') r = { tl: r, tr: r, br: r, bl: r };
  ctx.beginPath();
  ctx.moveTo(x + r.tl, y);
  ctx.lineTo(x + w - r.tr, y);
  ctx.quadraticCurveTo(x + w, y, x + w, y + r.tr);
  ctx.lineTo(x + w, y + h - r.br);
  ctx.quadraticCurveTo(x + w, y + h, x + w - r.br, y + h);
  ctx.lineTo(x + r.bl, y + h);
  ctx.quadraticCurveTo(x, y + h, x, y + h - r.bl);
  ctx.lineTo(x, y + r.tl);
  ctx.quadraticCurveTo(x, y, x + r.tl, y);
  if (fill) ctx.fill();
  if (stroke) ctx.stroke();
}
function ellipse(ctx, x, y, rx, ry, fill, stroke) {
  ctx.beginPath();
  ctx.ellipse(x, y, rx, ry, 0, 0, Math.PI * 2);
  if (fill) ctx.fill();
  if (stroke) ctx.stroke();
}
function rotateX(x, y, deg) {
  const r = (deg * Math.PI) / 180; return x * Math.cos(r) - y * Math.sin(r);
}
function rotateY(x, y, deg) {
  const r = (deg * Math.PI) / 180; return x * Math.sin(r) + y * Math.cos(r);
}
// Duplicate rand function removed to avoid redeclaration error. The global `rand` defined earlier will be used instead.
// function rand(min, max) { return Math.random() * (max - min) + min; }
// log.js

let incidentLog = [];

function addLog(message, type = 'info', timeText = null) {
  // Use simulation timer for timestamps if no custom time provided. This
  // helps correlate log entries with scenario time rather than real clock time.
  let stamp;
  if (timeText !== null) {
    stamp = timeText;
  } else {
    // If the global state exists, derive minutes and seconds from state.seconds
    const secs = (typeof state !== 'undefined' && state && typeof state.seconds === 'number') ? state.seconds : 0;
    const mins = String(Math.floor(secs / 60)).padStart(2, '0');
    const s = String(secs % 60).padStart(2, '0');
    stamp = `${mins}:${s}`;
  }
  const entry = {
    time: stamp,
    message,
    type
  };
  incidentLog.push(entry);
  const logEl = document.getElementById('scenario-log');
  if (logEl) {
    const cls = type === 'good' ? 'border-green-500' :
                type === 'bad' ? 'border-red-500' :
                type === 'command' ? 'border-amber-500' : 'border-gray-500';
    logEl.innerHTML += `<div class="border-l-4 ${cls} pl-2 text-sm"><span class="text-gray-400">[${entry.time}]</span> ${entry.message}</div>`;
    logEl.scrollTop = logEl.scrollHeight;
  }
}
function clearLog() { incidentLog = []; }
// sim.js

function vitalTrendLine(c) {
  const v = c.vitals;
  const p = c.prevVitals || v;
  // Generate a coloured arrow span based on the direction of change.
  const arrowSpan = (curr, prev) => {
    if (curr > prev) return '<span class="text-green-400">▲</span>';
    if (curr < prev) return '<span class="text-red-400">▼</span>';
    return '<span class="text-yellow-400">▬</span>';
  };
  return `GCS:${v.GCS} ${arrowSpan(v.GCS, p.GCS)} | ` +
         `HR:${v.HR} ${arrowSpan(v.HR, p.HR)} | ` +
         `RR:${v.RR} ${arrowSpan(v.RR, p.RR)} | ` +
         `SBP:${v.SBP} ${arrowSpan(v.SBP, p.SBP)} | ` +
         `SpO2:${v.SpO2}% ${arrowSpan(v.SpO2, p.SpO2)}`;
}

function simulationTick(allCasualties) {
  // When deterioration is paused, apply only random noise and return early
  if (state.deteriorationPaused) {
    (allCasualties || []).forEach(cas => {
      cas.prevVitals = { ...cas.vitals };
      // Apply gentle random noise to keep vitals dynamic
      cas.vitals.HR += Math.random() < 0.25 ? (Math.random() < 0.5 ? 1 : -1) : 0;
      cas.vitals.RR += Math.random() < 0.2 ? (Math.random() < 0.5 ? 1 : -1) : 0;
    });
    return;
  }
  // Deterioration factor slows down physiological decline (reduced further for slower decline)
  const deteriorationFactor = 0.25;
  (allCasualties || []).forEach(cas => {
    cas.prevVitals = { ...cas.vitals };
    let changed = false;
    (cas.injuries || []).forEach(inj => {
      if (cas.treatedInjuries?.has?.(inj.key)) return;
      if (inj.deterioration) {
        Object.entries(inj.deterioration).forEach(([k, delta]) => {
          const before = cas.vitals[k];
          // Apply scaled deterioration
          const adjustment = delta * deteriorationFactor;
          if (k === 'GCS') cas.vitals[k] = Math.max(3, Math.round(before + adjustment));
          else cas.vitals[k] = Math.round(before + adjustment);
          changed = true;
        });
      }
    });
    // Apply gentle random noise
    cas.vitals.HR += Math.random() < 0.25 ? (Math.random() < 0.5 ? 1 : -1) : 0;
    cas.vitals.RR += Math.random() < 0.2 ? (Math.random() < 0.5 ? 1 : -1) : 0;
    if (changed) {
      addLog(`Casualty ${cas.id + 1} showing deterioration.`, 'bad');
      // Flash red around the vitals when a casualty deteriorates
      const vitalsEl = document.getElementById(`vitals-${cas.id}`);
      if (vitalsEl) {
        vitalsEl.classList.add('flash-red');
        setTimeout(() => {
          vitalsEl.classList.remove('flash-red');
        }, 1000);
      }
    }
  });
}

function applyIntervention(cas, injuryKey, interventionKey, btnEl) {
  const inj = cas?.injuries?.find(i => i.key === injuryKey);
  const intervention = inj?.interventions?.[interventionKey];
  if (!inj || !intervention) return;

  cas.prevVitals = { ...cas.vitals };

  Object.entries(intervention.effect || {}).forEach(([k, v]) => {
    cas.vitals[k] = Math.max(0, Math.round(cas.vitals[k] + v));
  });

  if (intervention.stopsDeterioration) {
    cas.treatedInjuries.add(injuryKey);
    if (btnEl) btnEl.disabled = true;
  }
  addLog(`Intervention on Casualty ${cas.id + 1}: ${intervention.feedback}`, 'good');
}
// ui.js

let state = {
  scenario: null,
  timer: null,
  simTicker: null,
  seconds: 0,
  paused: true,
  // flag to pause deterioration independently of the overall simulation
  deteriorationPaused: false,
  options: {
    includeEVBatteryHazard: false,
    forceHazards: [],
    hazardProbability: 0.55
  }
};

function showMenu() {
  const app = document.getElementById('app');
  app.innerHTML = `
    <div id="main-menu" class="bg-gray-800 p-6 rounded-lg shadow-2xl">
      <h2 class="text-2xl font-bold mb-4">Generate Scenario</h2>

      <div id="controls" class="grid grid-cols-1 md:grid-cols-2 gap-4">
        <div class="bg-gray-900 p-4 rounded-lg">
          <h3 class="text-lg font-bold text-white mb-2">RTC Scenario</h3>
          <label class="block text-sm text-gray-300 mb-1">Vehicles</label>
          <select id="rtc-vehicles" class="bg-gray-700 border border-gray-600 rounded-lg w-full p-2 mb-2">
            <option>1</option><option selected>2</option><option>3</option>
          </select>
          <label class="block text-sm text-gray-300 mb-1">Patients</label>
          <select id="rtc-patients" class="bg-gray-700 border border-gray-600 rounded-lg w-full p-2 mb-2">
            <option>1</option><option selected>2</option><option>3</option><option>4</option><option>5</option>
          </select>

          <div class="mt-3 space-y-2">
            <label class="flex items-center gap-2">
              <input id="opt-evhaz" type="checkbox" class="h-4 w-4">
              <span class="text-sm">Include EV battery hazard if EV present</span>
            </label>

            <label class="block text-sm text-gray-300">Force hazards (override random):</label>
            <div class="grid grid-cols-2 gap-1 text-sm text-gray-200">
              ${['Fuel Spill','Fire','Battery Fire','Wall','Lamppost'].map(h =>
                `<label class="flex items-center gap-2"><input type="checkbox" class="force-hazard" value="${h}"/><span>${h}</span></label>`
              ).join('')}
            </div>

            <label class="block text-sm text-gray-300 mt-2">Hazard probability (<span id="hpLabel">${(state.options.hazardProbability*100)|0}</span>%):</label>
            <input id="opt-hp" type="range" min="0" max="100" value="${(state.options.hazardProbability*100)|0}" class="w-full">
          </div>

          <button id="genRtc" class="btn btn-primary w-full mt-3">Generate RTC</button>
        </div>

        <div class="bg-gray-900 p-4 rounded-lg">
          <h3 class="text-lg font-bold text-white mb-2">Trauma Scenario</h3>
          <label class="block text-sm text-gray-300 mb-1">Patients</label>
          <select id="trauma-patients" class="bg-gray-700 border border-gray-600 rounded-lg w-full p-2 mb-2">
            <option>1</option><option selected>2</option><option>3</option><option>4</option>
          </select>

          <div class="mt-3 space-y-2">
            <label class="flex items-center gap-2">
              <input id="opt-evhaz-trauma" type="checkbox" class="h-4 w-4">
              <span class="text-sm">Include EV battery hazard (if EV present in scene)</span>
            </label>

            <label class="block text-sm text-gray-300">Force hazards (override random):</label>
            <div class="grid grid-cols-2 gap-1 text-sm text-gray-200">
              ${['Fuel Spill','Fire','Battery Fire','Wall','Lamppost'].map(h =>
                `<label class="flex items-center gap-2"><input type="checkbox" class="force-hazard-trauma" value="${h}"/><span>${h}</span></label>`
              ).join('')}
            </div>

            <label class="block text-sm text-gray-300 mt-2">Hazard probability (<span id="hpLabelT">${(state.options.hazardProbability*100)|0}</span>%):</label>
            <input id="opt-hp-trauma" type="range" min="0" max="100" value="${(state.options.hazardProbability*100)|0}" class="w-full">
          </div>

          <button id="genTrauma" class="btn btn-secondary w-full mt-3">Generate Trauma</button>
        </div>
      </div>
    </div>
  `;

  const hp = document.getElementById('opt-hp');
  const hpT = document.getElementById('opt-hp-trauma');
  const hpLabel = document.getElementById('hpLabel');
  const hpLabelT = document.getElementById('hpLabelT');
  hp.addEventListener('input', e => { state.options.hazardProbability = Number(e.target.value)/100; hpLabel.textContent = e.target.value; });
  hpT.addEventListener('input', e => { state.options.hazardProbability = Number(e.target.value)/100; hpLabelT.textContent = e.target.value; });
}

function renderSetupScreen(scenario) {
  state = { ...state, scenario, timer: null, simTicker: null, seconds: 0, paused: true };
  clearLog();

  const app = document.getElementById('app');
  const cas = scenario.casualties || [];
  const veh = scenario.vehicles || [];
  const detailsHtml = `
    <p><strong>Location:</strong> ${scenario.location}</p>
    <p><strong>Time Limit:</strong> <span class="font-bold text-red-400">${scenario.timeLimit} mins</span></p>
    <p><strong>Hazards:</strong> <span class="text-yellow-400">${scenario.hazards}</span></p>
  `;

  const casualtiesHtml = cas.map(c => {
    const injuries = (c.injuries || []).map(i => i.name).join(', ');
    return `
      <div class="bg-gray-900 p-3 rounded">
        <div class="flex items-center justify-between">
          <h4 class="font-bold">Casualty ${c.id + 1} — Age ${c.age}</h4>
          <span class="font-mono text-sm bg-black px-2 py-1 rounded">
            GCS:${c.vitals.GCS} | HR:${c.vitals.HR} | RR:${c.vitals.RR} | SBP:${c.vitals.SBP} | SpO2:${c.vitals.SpO2}%
          </span>
        </div>
        <p class="text-amber-400 text-sm mt-1"><strong>Suspected:</strong> ${injuries}</p>
        <p class="text-gray-400 text-sm mt-1"><strong>AMPLE:</strong> A:${c.ample.A} | M:${c.ample.M} | P:${c.ample.P} | L:${c.ample.L} | E:${c.ample.E}</p>
      </div>
    `;
  }).join('');

  const vehiclesHtml = veh.map((v, idx) => `
    <div class="bg-gray-900 p-3 rounded">
      <h4 class="font-bold">Vehicle ${String.fromCharCode(65+idx)} — ${v.type}</h4>
      <p class="text-sm">Position: ${v.position.name} | Damage: ${v.damage}</p>
      <p class="text-sm">UHSS: ${v.hasUHSS ? '<span class="chip chip-uhss">UHSS</span>' : 'No'} |
         EV: ${v.isEV ? '<span class="chip chip-ev">EV</span>' : 'No'}</p>
    </div>
  `).join('');

  app.innerHTML = `
    <div id="setup-screen" class="bg-gray-800 p-6 rounded-lg shadow-2xl space-y-6">
      <div class="flex justify-between items-center">
        <h2 class="text-2xl font-bold">Instructor Briefing</h2>
        <div class="flex gap-2">
          <button id="backBtn" class="btn btn-secondary">Back</button>
          <button id="printBtn" class="btn btn-tertiary">Print Briefing</button>
        </div>
      </div>

      <div class="grid grid-cols-1 lg:grid-cols-5 gap-6">
        <div class="lg:col-span-3 bg-gray-900 p-4 rounded-lg">
          <h3 class="text-xl font-bold mb-2">Top-Down View</h3>
          <canvas id="setupCanvas" width="${scenario.canvas.width}" height="${scenario.canvas.height}" class="w-full h-auto bg-gray-700 rounded"></canvas>
        </div>
        <div class="lg:col-span-2 bg-gray-900 p-4 rounded-lg">
          <h3 class="text-xl font-bold mb-2">Incident Details</h3>
          <div class="text-sm space-y-2">${detailsHtml}${vehiclesHtml}</div>
        </div>
      </div>

      <div>
        <h3 class="text-xl font-bold mb-2">Casualty Briefing Sheets</h3>
        <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
          ${casualtiesHtml}
        </div>
      </div>

      <div class="text-center">
        <button id="startSimBtn" class="btn btn-primary w-full md:w-1/2 mt-2">Proceed to Live Simulation</button>
      </div>
      <!-- Placeholder for the live simulation. Hidden by default until the user proceeds. -->
      <div id="live-sim-wrapper" class="mt-6 hidden"></div>
    </div>
  `;

  const canvas = document.getElementById('setupCanvas');
  drawSetupScene(canvas, scenario);

  document.getElementById('printBtn').addEventListener('click', () => window.print());
  document.getElementById('backBtn').addEventListener('click', showMenu);
  // When the user clicks proceed, hide the start button, reveal the live sim wrapper
  // and render the live simulation below the briefing instead of replacing the entire page.
  document.getElementById('startSimBtn').addEventListener('click', () => {
    const btn = document.getElementById('startSimBtn');
    if (btn) btn.style.display = 'none';
    const wrapper = document.getElementById('live-sim-wrapper');
    if (wrapper) {
      wrapper.classList.remove('hidden');
      renderLiveSim(scenario, 'live-sim-wrapper');
    } else {
      // Fallback: if wrapper is missing, render normally to the app container
      renderLiveSim(scenario);
    }
  });
}

function renderVitalLineWithTrends(c) {
  return vitalTrendLine(c);
}

function bindInterventions(allCasualties) {
  document.querySelectorAll('.intervention-btn').forEach(btn => {
    btn.addEventListener('click', e => {
      const { casualtyId, injuryKey, interventionKey } = e.currentTarget.dataset;
      const cas = allCasualties.find(c => c.id == casualtyId);
      applyIntervention(cas, injuryKey, interventionKey, e.currentTarget);
      const vitalsEl = document.getElementById(`vitals-${cas.id}`);
      if (vitalsEl) vitalsEl.innerHTML = renderVitalLineWithTrends(cas);
    });
  });
}

// Render the live simulation. If a targetId is provided, inject the content into
// that element instead of replacing the entire app. This allows the live
// simulation to appear below the briefing on the same page when proceeding
// from the Instructor Briefing.
function renderLiveSim(scenario, targetId) {
  const container = targetId ? document.getElementById(targetId) : document.getElementById('app');
  const allCasualties = scenario.casualties;

  // Define casualty actions and scenario actions arrays for dynamic button generation
  const casualtyActions = [
    'Hands on Patient',
    'Primary Survey Started',
    'C-ABCDE Complete',
    'Airway Managed',
    'Oxygen Applied',
    'Haemorrhage Control',
    'Spinal Immobilisation',
    'Packaging Complete',
    'Extrication Started',
    'Extrication Complete',
    'Reassessment Done',
    'ATMIST Handover'
  ];
  const scenarioActions = [
    'Scene Size-Up Complete',
    '360 Survey Complete',
    'Hazards Identified',
    'Vehicle Stab Started',
    'Vehicle Stab Complete',
    'Glass Management',
    'Rapid Plan Viable',
    'Tactical Plan Announced',
    'Access Created',
    'Extrication Path Clear',
    'EV/UHSS Managed',
    'Emergency Services Notified'
  ];

  // Build casualty cards with medical action buttons and interventions
  // Group casualty actions into logical categories for clarity
  const casualtyActionGroups = [
    { title: 'Initial Assessment', actions: ['Hands on Patient','Primary Survey Started','C-ABCDE Complete','Reassessment Done'] },
    { title: 'Airway & Circulation', actions: ['Airway Managed','Oxygen Applied','Haemorrhage Control','Spinal Immobilisation'] },
    { title: 'Packaging & Extrication', actions: ['Packaging Complete','Extrication Started','Extrication Complete'] },
    { title: 'Handover', actions: ['ATMIST Handover'] }
  ];

  // Group scenario actions into logical categories for improved organisation.
  // These categories reflect the typical sequence of tasks during an RTC rescue
  // and make it easier for instructors to find and record key events.  Each
  // category will be displayed with a small heading and its associated
  // buttons in the live simulation view.
  const scenarioActionGroups = [
    { title: 'Scene Assessment', actions: ['Scene Size-Up Complete','360 Survey Complete','Hazards Identified'] },
    { title: 'Stabilisation & Glass', actions: ['Vehicle Stab Started','Vehicle Stab Complete','Glass Management'] },
    { title: 'Plan & Communication', actions: ['Rapid Plan Viable','Tactical Plan Announced','EV/UHSS Managed','Emergency Services Notified'] },
    { title: 'Extrication', actions: ['Access Created','Extrication Path Clear'] }
  ];
  const casCards = allCasualties.map(c => {
    // Build intervention buttons
    const ints = (c.injuries || []).flatMap(inj => {
      const intList = inj.interventions ? Object.values(inj.interventions) : [];
      return intList.map(iv => `<button class="intervention-btn bg-indigo-600 hover:bg-indigo-700 text-white text-xs font-bold py-1 px-2 rounded"
        data-casualty-id="${c.id}" data-injury-key="${inj.key}" data-intervention-key="${iv.key}" title="${iv.key}">${iv.key}</button>`);
    }).join(' ');
    // Build casualty actions grouped by category
    const casualtyActionBtns = casualtyActionGroups.map(group => {
      const btns = group.actions.map(action =>
        `<button class="casualty-action-btn bg-emerald-600 hover:bg-emerald-700 text-white text-xs font-bold py-1 px-2 rounded"
          data-casualty-id="${c.id}" data-action="${action}" title="${action}">${action}</button>`
      ).join(' ');
      return `
        <div class="mb-1">
          <p class="text-xs text-gray-400">${group.title}:</p>
          <div class="flex flex-wrap gap-1 mb-1">${btns}</div>
        </div>
      `;
    }).join('');
    return `
      <div class="bg-gray-900 p-3 rounded">
        <h4 class="font-bold">Casualty ${c.id + 1}</h4>
        <div id="vitals-${c.id}" class="font-mono text-center my-2 p-2 bg-black rounded">${renderVitalLineWithTrends(c)}</div>
        <div class="mb-2">
          <p class="text-xs text-gray-400 mb-1">Medical Actions:</p>
          ${casualtyActionBtns}
        </div>
        <div>
          <p class="text-xs text-gray-400 mb-1">Interventions:</p>
          <div class="flex flex-wrap gap-2 justify-center">${ints || '<span class="text-gray-400 text-sm">No specific interventions</span>'}</div>
        </div>
      </div>
    `;
  }).join('');

  // Build scenario action buttons grouped by category.  Each group
  // generates a heading and its own set of buttons, similar to how
  // casualty actions are grouped.  Grouping these improves clarity
  // when many actions are available.
  const scenarioActionBtns = scenarioActionGroups.map(group => {
    const btns = group.actions.map(action =>
      `<button class="scenario-action-btn bg-amber-600 hover:bg-amber-700 text-white text-xs font-bold py-1 px-2 rounded"
        data-action="${action}" title="${action}">${action}</button>`
    ).join(' ');
    return `
      <div class="mb-1">
        <p class="text-xs text-gray-400">${group.title}:</p>
        <div class="flex flex-wrap gap-1 mb-1">${btns}</div>
      </div>
    `;
  }).join('');

  container.innerHTML = `
    <div id="live-sim" class="bg-gray-800 p-6 rounded-lg shadow-2xl space-y-6">
      <div class="flex justify-between items-center">
        <button id="backBtn" class="btn btn-secondary">Back</button>
        <div class="flex items-center gap-2">
          <div id="timer" class="text-2xl font-mono font-bold text-red-400 bg-gray-900 px-3 py-1 rounded-md">00:00</div>
          <button id="timerControlBtn" class="btn btn-tertiary w-28">Start Sim</button>
          <button id="deteriorationControlBtn" class="btn btn-tertiary w-40">Pause Deterioration</button>
        </div>
      </div>
      <div class="bg-gray-900 p-4 rounded-lg mb-4">
        <h3 class="text-lg font-bold mb-2 text-amber-400">Command & Technical Actions</h3>
        <!-- Use a vertical layout for grouped scenario actions to improve readability -->
        <div class="space-y-1">${scenarioActionBtns}</div>
      </div>
      <div class="grid grid-cols-1 md:grid-cols-3 gap-4">${casCards}</div>
      <div>
        <h3 class="text-xl font-bold">Incident Log</h3>
        <div id="scenario-log" class="h-40 bg-gray-900 rounded-lg p-2 mt-2 overflow-y-auto text-sm font-mono"></div>
        <div class="flex gap-2 mt-2">
          <input type="text" id="manualLogInput" class="flex-grow bg-gray-700 border-gray-600 rounded p-2" placeholder="Log instructor observation...">
          <button id="addLogBtn" class="btn btn-primary">Add Log</button>
        </div>
      </div>
      <div class="text-center">
        <button id="finishBtn" class="btn btn-primary w-full md:w-1/2 mt-2">Finish & Debrief</button>
      </div>
    </div>
  `;

  // Attach event listeners to buttons within the rendered live simulation.
  document.getElementById('backBtn').addEventListener('click', () => {
    // When placed inside a wrapper, back should return to the briefing by
    // hiding the live simulation and showing the start button again.
    const wrapper = document.getElementById('live-sim-wrapper');
    const startBtn = document.getElementById('startSimBtn');
    if (wrapper && startBtn) {
      wrapper.classList.add('hidden');
      // Remove the rendered simulation content
      wrapper.innerHTML = '';
      startBtn.style.display = '';
    } else {
      // Fallback to full reload of briefing
      renderSetupScreen(scenario);
    }
  });

  document.getElementById('timerControlBtn').addEventListener('click', () => {
    state.paused = !state.paused;
    const btn = document.getElementById('timerControlBtn');
    btn.textContent = state.paused ? 'Resume Sim' : 'Pause Sim';
    if (!state.paused) {
      if (!state.timer) {
        addLog('Simulation Started.', 'command', '00:00');
        state.timer = setInterval(() => {
          state.seconds++;
          const mins = String(Math.floor(state.seconds / 60)).padStart(2, '0');
          const secs = String(state.seconds % 60).padStart(2, '0');
          document.getElementById('timer').textContent = `${mins}:${secs}`;
        }, 1000);
      }
      if (!state.simTicker) {
        state.simTicker = setInterval(() => {
          simulationTick(allCasualties);
          allCasualties.forEach(c => {
            const el = document.getElementById(`vitals-${c.id}`);
            if (el) el.innerHTML = renderVitalLineWithTrends(c);
          });
        }, 45000); // run deterioration tick every 45 seconds (slower)
      }
    } else {
      addLog('Simulation Paused.', 'command');
    }
  });

  // Toggle deterioration separately from overall sim
  document.getElementById('deteriorationControlBtn').addEventListener('click', () => {
    state.deteriorationPaused = !state.deteriorationPaused;
    const btnD = document.getElementById('deteriorationControlBtn');
    btnD.textContent = state.deteriorationPaused ? 'Resume Deterioration' : 'Pause Deterioration';
    addLog(state.deteriorationPaused ? 'Deterioration paused.' : 'Deterioration resumed.', 'command');
  });

  const addManual = () => {
    const input = document.getElementById('manualLogInput');
    if (input.value.trim()) {
      addLog(`<strong>Instructor Note:</strong> ${input.value.trim()}`, 'command');
      input.value = '';
    }
  };
  document.getElementById('addLogBtn').addEventListener('click', addManual);
  document.getElementById('manualLogInput').addEventListener('keypress', e => { if (e.key === 'Enter') addManual(); });

  document.getElementById('finishBtn').addEventListener('click', () => renderDebrief(scenario));

  bindInterventions(allCasualties);

  // Attach click handlers for casualty- and scenario-level action buttons.  These
  // buttons allow the instructor to record when key tasks have been performed
  // during the simulation without removing other functionality.  When clicked
  // they log the action and disable themselves so each action can only be
  // recorded once.
  document.querySelectorAll('.casualty-action-btn').forEach(btn => {
    btn.addEventListener('click', (event) => {
      const { casualtyId, action } = event.currentTarget.dataset;
      // Log the casualty action with a prefix indicating the casualty number
      addLog(`Casualty ${parseInt(casualtyId, 10) + 1}: ${action}`, 'command');
      // Disable the button and give it a faded appearance to show it has been used
      event.currentTarget.disabled = true;
      event.currentTarget.classList.add('opacity-50');
    });
  });
  document.querySelectorAll('.scenario-action-btn').forEach(btn => {
    btn.addEventListener('click', (event) => {
      const { action } = event.currentTarget.dataset;
      // Log the scenario-level action
      addLog(action, 'command');
      // Disable the button and fade it out
      event.currentTarget.disabled = true;
      event.currentTarget.classList.add('opacity-50');
    });
  });
}

function renderDebrief(scenario) {
  if (state.timer) clearInterval(state.timer);
  if (state.simTicker) clearInterval(state.simTicker);
  state.timer = null; state.simTicker = null;

  const app = document.getElementById('app');
  const domains = scenario.type === 'RTC' ? ['command', 'technical', 'trauma'] : ['command', 'trauma'];

  const timelineHtml = incidentLog.map(e =>
    `<p><span class="text-gray-500">[${e.time}]</span> ${e.message.replace(/<[^>]*>/g, '')}</p>`
  ).join('');

  // Build a summary of vital signs showing how each casualty's key vitals
  // changed from the start of the scenario to the end.  This helps
  // instructors quickly identify overall trends in patient condition during
  // debrief.  Differences are expressed with arrows and the numerical
  // change (e.g., "HR: 80→90 (+10)").
  const allCasualties = scenario.casualties || (scenario.vehicles ? scenario.vehicles.flatMap(v => v.casualties) : []);
  const vitalsSummaryHtml = (allCasualties || []).map((c, idx) => {
    const init = c.initialVitals || {};
    const final = c.vitals || {};
    const parts = [];
    ['GCS','HR','RR','SBP','SpO2'].forEach(key => {
      if (init[key] !== undefined && final[key] !== undefined) {
        const diff = final[key] - init[key];
        const arrow = diff > 0 ? '↑' : diff < 0 ? '↓' : '→';
        const sign = diff > 0 ? '+' : (diff < 0 ? '' : '');
        parts.push(`${key}: ${init[key]}→${final[key]} (${sign}${diff})`);
      }
    });
    return `<p><strong>Casualty ${idx + 1}:</strong> ${parts.join('; ')}</p>`;
  }).join('');

  const checklists = domains.map(domain => `
    <div class="bg-gray-900 p-4 rounded-lg mb-4">
      <h3 class="text-xl font-bold capitalize text-amber-500">${domain}</h3>
      <div class="mt-2 space-y-2">
        ${(frameworkData.scoresheets[domain] || []).map((item, idx) => `
          <div class="flex items-start">
            <input id="${domain}-${idx}" type="checkbox" class="h-5 w-5 rounded mt-1 bg-gray-700 border-gray-600">
            <label for="${domain}-${idx}" class="ml-3 text-sm flex-grow">${item}</label>
          </div>
          <textarea class="bg-gray-700 w-full text-sm rounded-md p-1 mt-1 border border-gray-600" rows="1" placeholder="Notes..."></textarea>
        `).join('')}
      </div>
    </div>
  `).join('');

  app.innerHTML = `
    <div id="debrief-screen" class="bg-gray-800 p-6 rounded-lg shadow-2xl space-y-6">
      <div class="flex justify-between items-center">
        <h2 class="text-2xl font-bold">Post-Scenario Debrief</h2>
        <div class="flex gap-2">
          <button id="exportPdfBtn" class="btn btn-tertiary">Export PDF</button>
          <button id="backBtn" class="btn btn-secondary">Back to Menu</button>
        </div>
      </div>

      <div class="bg-gray-900 p-4 rounded-lg">
        <h3 class="text-xl font-bold text-amber-500">Incident Timeline</h3>
        <div id="debrief-timeline" class="mt-2 space-y-1 font-mono text-sm max-h-64 overflow-y-auto">${timelineHtml}</div>
      </div>

      <!-- Summary of changes in vitals for each casualty -->
      <div class="bg-gray-900 p-4 rounded-lg">
        <h3 class="text-xl font-bold text-amber-500">Vital Signs Summary</h3>
        <div class="mt-2 space-y-1 text-sm">${vitalsSummaryHtml || '<p>No casualties.</p>'}</div>
      </div>

      ${checklists}

      <div class="text-center">
        <button id="newScenarioBtn" class="btn btn-primary w-full md:w-1/2 mt-2">Start New Scenario</button>
      </div>
    </div>
  `;

  document.getElementById('backBtn').addEventListener('click', () => showMenu());
  document.getElementById('newScenarioBtn').addEventListener('click', () => location.reload());
  document.getElementById('exportPdfBtn').addEventListener('click', exportDebriefAsPdf);
}

async function exportDebriefAsPdf() {
  const el = document.getElementById('debrief-screen');
  const { jsPDF } = window.jspdf;
  const canvas = await html2canvas(el, { scale: 2, backgroundColor: '#ffffff' });
  const imgData = canvas.toDataURL('image/png');
  const pdf = new jsPDF('p', 'pt', 'a4');

  const pageWidth = pdf.internal.pageSize.getWidth();
  const pageHeight = pdf.internal.pageSize.getHeight();

  const imgWidth = pageWidth - 40;
  const ratio = canvas.height / canvas.width;
  const imgHeight = imgWidth * ratio;

  let y = 20;
  let x = 20;

  if (imgHeight < pageHeight - 40) {
    pdf.addImage(imgData, 'PNG', x, y, imgWidth, imgHeight);
  } else {
    let remaining = imgHeight;
    let position = 0;
    const pageCanvas = document.createElement('canvas');
    const pageCtx = pageCanvas.getContext('2d');
    pageCanvas.width = canvas.width;
    const pagePixels = Math.floor((pageHeight - 40) * (canvas.width / imgWidth));
    while (remaining > 0) {
      const sliceHeight = Math.min(pagePixels, remaining);
      pageCanvas.height = sliceHeight;
      pageCtx.drawImage(canvas, 0, position, canvas.width, sliceHeight, 0, 0, canvas.width, sliceHeight);
      const sliceData = pageCanvas.toDataURL('image/png');
      const sliceHeightPt = (sliceHeight / canvas.width) * imgWidth;
      pdf.addImage(sliceData, 'PNG', x, y, imgWidth, sliceHeightPt);
      remaining -= sliceHeight;
      position += sliceHeight;
      if (remaining > 0) pdf.addPage();
    }
  }
  pdf.save('UKRO_Debrief.pdf');
}// main.js
// Entry point for the UKRO scenario simulator.
// This script hooks up the UI buttons to the scenario generation functions
// and passes user-selected options (like hazard probability and EV hazards)
// to the scenario generator. It also attaches score sheets from the
// framework data to each scenario for debriefing.


// Initialise the application once the DOM is ready.
document.addEventListener('DOMContentLoaded', () => {
  // Render the main menu with scenario generation options.
  showMenu();

  // Centralised click handler for buttons on the page. This avoids
  // attaching individual listeners to each button and ensures we
  // correctly capture events even if elements are re-rendered.
  document.addEventListener('click', e => {
    // Generate RTC scenario button clicked
    if (e.target.id === 'genRtc') {
      const nVeh = parseInt(document.getElementById('rtc-vehicles').value, 10);
      const nPat = parseInt(document.getElementById('rtc-patients').value, 10);
      // Validate patient count against vehicle capacity (max 5 per vehicle)
      if (nPat > nVeh * 5) {
        alert('Patient count exceeds vehicle capacity.');
        return;
      }
      // Read hazard options from UI controls
      const includeEVBatteryHazard = document.getElementById('opt-evhaz').checked;
      const hazardProbability = Number(document.getElementById('opt-hp').value) / 100;
      const forceHazards = [...document.querySelectorAll('.force-hazard:checked')].map(cb => cb.value);

      // Generate a new RTC scenario using the selected options
      const scenario = generateRtcScenario(nVeh, nPat, {
        includeEVBatteryHazard,
        hazardProbability,
        forceHazards
      });
      // Attach scoring categories so the debrief can build its checklist
      scenario.scoresheets = frameworkData.scoresheets;
      // Display the setup/briefing screen for the generated scenario
      renderSetupScreen(scenario);
    }
    // Generate Trauma scenario button clicked
    if (e.target.id === 'genTrauma') {
      const nPat = parseInt(document.getElementById('trauma-patients').value, 10);
      const includeEVBatteryHazard = document.getElementById('opt-evhaz-trauma').checked;
      const hazardProbability = Number(document.getElementById('opt-hp-trauma').value) / 100;
      const forceHazards = [...document.querySelectorAll('.force-hazard-trauma:checked')].map(cb => cb.value);

      // Generate a trauma scenario with the chosen options
      const scenario = generateTraumaScenario(nPat, {
        includeEVBatteryHazard,
        hazardProbability,
        forceHazards
      });
      scenario.scoresheets = frameworkData.scoresheets;
      renderSetupScreen(scenario);
    }
  });
});
  </script>
</body>
</html>